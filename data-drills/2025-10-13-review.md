# Data Drills Review - October 13, 2025
**Week:** 1 | **Difficulty:** Beginner | **Session:** 1

---

## Problem 1: Product Filtering ⭐⭐
**Time Taken:** 15 minutes

### Original Code (Issues Found):
```typescript
type ProductsType = {
  id: number;
  name: string;
  price: number;
  inStock: boolean;
  category: string;
}[];

const productFilter = (products: ProductsType): ProductsType => {
  if (products.length === 0 || !products) return [];

  const filteredProducts = products.filter((product) => {
    if (product.inStock && product.price < 500) {
      return {
        name: product.name,
        price: product.price,
      };
    }
  });

  console.log(filteredProducts);
  return filteredProducts;
};
```

### Issues Identified:
1. **Wrong return type** - Function returned `ProductsType` (full objects) but task required only `{ name, price }`
2. **Misunderstanding of `filter`** - Tried to return transformed object inside filter, but filter only checks truthy/falsy
3. **Missing transformation step** - Needed `map()` after `filter()` to change object shape
4. **Initial condition error** - First attempt had `product.price > 500` instead of `< 500`

### Final Solution:
```typescript
type ProductsReturnedType = {
  name: string;
  price: number;
}[];

const productFilter = (products: ProductsType): ProductsReturnedType => {
  if (products.length === 0) return [];

  const filteredProject = products
    .filter((product) => product.price < 500 && product.inStock)
    .map((product) => ({
      name: product.name,
      price: product.price,
    }));

  return filteredProject;
};
```

### Key Learning:
- **Pattern:** `filter()` + `map()` for filtering and transforming data shape
- Need separate output type when return shape differs from input

---

## Problem 2: User Score Calculation ⭐⭐
**Time Taken:** 7 minutes

### Original Code (Issues Found):
```typescript
type UsersType = {
  username: string;
  points: number;
  level: number;
}[];

const scoreCalculation = (users: UsersType): number => {
  if (users.length === 0) return 0;
  if (users.every((user) => user.level === 1)) return 0;

  let total = 0;

  for (let i = 0; i < users.length; i++) {
    if (users[i].level > 2) {  // WRONG: should be >= 2
      users[i].points += total;  // WRONG: backwards logic
    }
  }
  return total;
};
```

### Issues Identified:
1. **Wrong comparison operator** - Used `> 2` instead of `>= 2` (task said "level 2 or higher")
2. **Backwards accumulation** - Did `users[i].points += total` instead of `total += users[i].points`
3. **Unnecessary edge case check** - The `every()` check was redundant

### Final Solution:
```typescript
const scoreCalculation = (users: UsersType): number => {
  if (users.length === 0) return 0;

  let total = 0;

  for (let i = 0; i < users.length; i++) {
    if (users[i].level >= 2) {
      total += users[i].points;
    }
  }
  return total;
};
```

### Key Learning:
- Pay attention to "or equal to" vs "greater than" in requirements
- Accumulation pattern: `total += value` (add TO the accumulator)
- Could also use `filter().reduce()` for cleaner functional approach

---

## Problem 3: Order Status Update ⭐⭐
**Time Taken:** 6 minutes

### Final Solution (Correct on First Try):
```typescript
type OrdersType = {
  orderId: number;
  customerName: string;
  total: number;
  isPaid: boolean;
  status?: string;
}[];

const modifyOrders = (orders: OrdersType): OrdersType => {
  const modifiedOrders = orders.map((order) => {
    return {
      ...order,
      status: order.isPaid ? "complete" : "pending",
    };
  });

  return modifiedOrders;
};
```

### What Went Well:
- ✅ Correctly identified need for `map()` to transform each order
- ✅ Proper use of spread operator (`...order`) to preserve existing properties
- ✅ Clean ternary operator for conditional logic
- ✅ Made `status` optional in type definition

### Key Learning:
- **Pattern:** `map()` with spread operator for adding properties while keeping originals
- Ternary operators are clean for simple conditionals

---

## Session Summary

### Overall Performance:
**Total Time:** 28 minutes (on target for 30-minute goal)

**Problems Solved:**
- ✅ Problem 1: Fixed after guidance (15 min)
- ✅ Problem 2: Fixed after guidance (7 min)
- ✅ Problem 3: Correct first try (6 min)

### Patterns Practiced Today:
1. **Filter + Map** - For filtering and transforming data shape
2. **Accumulation with loops** - Building up totals with proper `+=` direction
3. **Map with spread operator** - Adding properties while preserving originals

### Struggles/Areas for Improvement:
1. **Understanding method purposes** - Initially confused about what `filter()` returns vs transforms
2. **Reading requirements carefully** - Missed "less than" vs "greater than" and ">=" vs ">"
3. **Accumulation direction** - Got the `+=` backwards initially

### Strengths Demonstrated:
1. **Quick correction** - Problems 2 and 3 solved much faster, showing learning curve
2. **Type definitions** - Good intuition for creating proper TypeScript types
3. **Problem 3 mastery** - Nailed the map + spread pattern on first try

### Progress Tracking:
- **Session:** 1/∞
- **Week:** 1 (Beginner)
- **Consecutive Days:** 1
- **Improvement trajectory:** N/A (first session - baseline established)

### Recommendation:
✅ **Ready for next beginner session** - Continue Week 1 difficulty
- Focus on reading requirements more carefully (comparison operators, thresholds)
- Continue practicing filter/map/reduce patterns
- Good momentum on Problem 3 shows pattern recognition is developing

---

**Next Session:** Continue Week 1 Beginner problems with similar complexity
